(Establish connectivity in Between MySQL + Jupiter Notebook)  
             Way 1:


import pandas as pd
import mysql.connector
import os


# List of CSV files and their corresponding table names
csv_files = [
    ('customers.csv', 'customers'),
    ('orders.csv', 'orders'),
    ('sellers.csv', 'sellers'),
    ('products.csv', 'products'),
    ('geolocation.csv', 'geolocation'),
    ('payments.csv', 'payments'),
    ('order_items.csv', 'order_items')  # Added payments.csv for specific handling
]


# Connect to the MySQL database
conn = mysql.connector.connect(
    host='localhost',
    user='root',
    password='830899',
    database='ecommerce'
)
cursor = conn.cursor()


# Folder containing the CSV files
folder_path = 'C:/Users/suyas/OneDrive/Desktop/Python Data Analytics/E-Commerce'


def get_sql_type(dtype):
    if pd.api.types.is_integer_dtype(dtype):
        return 'INT'
    elif pd.api.types.is_float_dtype(dtype):
        return 'FLOAT'
    elif pd.api.types.is_bool_dtype(dtype):
        return 'BOOLEAN'
    elif pd.api.types.is_datetime64_any_dtype(dtype):
        return 'DATETIME'
    else:
        return 'TEXT'


for csv_file, table_name in csv_files:
    file_path = os.path.join(folder_path, csv_file)
    
    # Read the CSV file into a pandas DataFrame
    df = pd.read_csv(file_path)
    
    # Replace NaN with None to handle SQL NULL
    df = df.where(pd.notnull(df), None)
    
    # Debugging: Check for NaN values
    print(f"Processing {csv_file}")
    print(f"NaN values before replacement:\n{df.isnull().sum()}\n")


    # Clean column names
    df.columns = [col.replace(' ', '_').replace('-', '_').replace('.', '_') for col in df.columns]


    # Generate the CREATE TABLE statement with appropriate data types
    columns = ', '.join([f'`{col}` {get_sql_type(df[col].dtype)}' for col in df.columns])
    create_table_query = f'CREATE TABLE IF NOT EXISTS `{table_name}` ({columns})'
    cursor.execute(create_table_query)


    # Insert DataFrame data into the MySQL table
    for _, row in df.iterrows():
        # Convert row to tuple and handle NaN/None explicitly
        values = tuple(None if pd.isna(x) else x for x in row)
        sql = f"INSERT INTO `{table_name}` ({', '.join(['`' + col + '`' for col in df.columns])}) VALUES ({', '.join(['%s'] * len(row))})"
        cursor.execute(sql, values)


    # Commit the transaction for the current CSV file
    conn.commit()


# Close the connection
conn.close()






































Way 2:


import os
import pandas as pd
import mysql.connector
from mysql.connector import Error


# ---------------- CONFIG ----------------
CSV_FOLDER = r'C:/Users/suyas/OneDrive/Desktop/Python Data Analytics/E-Commerce'
CSV_FILES = [
    ('customers.csv', 'customers'),
    ('orders.csv', 'orders'),
    ('sellers.csv', 'sellers'),
    ('products.csv', 'products'),
    ('geolocation.csv', 'geolocation'),
    ('payments.csv', 'payments'),
    ('order_items.csv', 'order_items'),
]


DB_CONFIG = {
    'host': 'localhost',    # <-- set to your host (127.0.0.1 or remote IP/host)
    'user': 'root',
    'password': '830899',
    'database': 'ecommerce', # DB to use/create
    'port': 3306
}


BATCH_SIZE = 1000
# ----------------------------------------


def print_mysql_error(e: Error):
    try:
        errno = e.errno
        msg = e.msg if hasattr(e, 'msg') else str(e)
    except Exception:
        errno = None
        msg = str(e)
    print(f"  MySQL Error: errno={errno} message={msg}")


    # Helpful hints for common errors:
    if errno == 2003:
        print("  -> Can't connect to MySQL server. Check host/port and firewall.")
    elif errno == 11001:
        print("  -> Hostname resolution failed. Check DB_CONFIG['host'].")
    elif errno == 1045:
        print("  -> Access denied. Check username/password and user host privileges.")
    elif errno == 1049:
        print("  -> Unknown database. The database may not exist (will attempt to create).")
    elif errno in (2059,):  # auth plugin errors may surface as different codes on some setups
        print("  -> Authentication plugin error. Try configuring auth_plugin to 'mysql_native_password' on server or client.")
    else:
        print("  -> See the error message above for details.")


def try_connect(config, use_database=True, auth_plugin=None, timeout=10):
    """Attempt to connect; optionally try with different auth plugin."""
    params = {
        'host': config['host'],
        'user': config['user'],
        'password': config['password'],
        'port': config.get('port', 3306),
        'connection_timeout': timeout
    }
    if use_database and config.get('database'):
        params['database'] = config['database']
    if auth_plugin:
        params['auth_plugin'] = auth_plugin


    try:
        conn = mysql.connector.connect(**params)
        print(f"✅ Connected to MySQL server (host={config['host']})"
              f"{' using database ' + config['database'] if use_database and config.get('database') else ''}"
              f"{' (auth_plugin=' + auth_plugin + ')' if auth_plugin else ''}.")
        return conn
    except Error as e:
        print("❌ Connection attempt failed.")
        print_mysql_error(e)
        return None


def ensure_database_exists(config):
    """Connect without database and create the DB if missing."""
    # Try normal connect without database
    print("-> Ensuring database exists:", config.get('database'))
    conn = try_connect(config, use_database=False)
    if conn is None:
        # Fallback: try with different auth_plugin if plugin issue suspected
        print("-> Trying fallback auth_plugin 'mysql_native_password'...")
        conn = try_connect(config, use_database=False, auth_plugin='mysql_native_password')
        if conn is None:
            raise SystemExit("Fatal: Cannot connect to MySQL server to create/check database. See errors above.")


    try:
        cursor = conn.cursor()
        db_name = config['database']
        if not db_name:
            raise SystemExit("ERROR: No database name provided in DB_CONFIG['database'].")
        create_sql = f"CREATE DATABASE IF NOT EXISTS `{db_name}` DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;"
        cursor.execute(create_sql)
        print(f"✅ Database `{db_name}` exists or was created.")
    except Error as e:
        print("❌ Could not create database.")
        print_mysql_error(e)
        raise
    finally:
        try:
            cursor.close()
            conn.close()
        except Exception:
            pass


def sanitize_colname(col: str) -> str:
    name = str(col).strip()
    name = name.replace(' ', '_').replace('-', '_').replace('.', '_').replace('/', '_')
    name = ''.join(ch for ch in name if ch.isalnum() or ch == '_')
    if name and name[0].isdigit():
        name = '_' + name
    if not name:
        name = 'col'
    return name[:64]


def get_sql_type(dtype) -> str:
    if pd.api.types.is_integer_dtype(dtype):
        return 'INT'
    if pd.api.types.is_float_dtype(dtype):
        return 'DOUBLE'
    if pd.api.types.is_bool_dtype(dtype):
        return 'BOOLEAN'
    if pd.api.types.is_datetime64_any_dtype(dtype):
        return 'DATETIME'
    return 'TEXT'


def create_table_from_df(cursor, table_name: str, df: pd.DataFrame):
    cols = []
    for col in df.columns:
        sql_type = get_sql_type(df[col].dtype)
        cols.append(f"`{col}` {sql_type}")
    columns_sql = ", ".join(cols) if cols else "`id` INT"
    create_sql = f"CREATE TABLE IF NOT EXISTS `{table_name}` ({columns_sql}) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;"
    cursor.execute(create_sql)


def insert_dataframe(cursor, conn, table_name: str, df: pd.DataFrame, batch_size: int = 1000):
    if df.empty:
        print(f"  - `{table_name}`: no rows to insert.")
        return 0
    cols = [f"`{c}`" for c in df.columns]
    placeholders = ", ".join(["%s"] * len(df.columns))
    insert_sql = f"INSERT INTO `{table_name}` ({', '.join(cols)}) VALUES ({placeholders})"
    rows = df.where(pd.notnull(df), None).values.tolist()
    inserted = 0
    try:
        for i in range(0, len(rows), batch_size):
            batch = rows[i:i+batch_size]
            cursor.executemany(insert_sql, batch)
            conn.commit()
            inserted += len(batch)
            print(f"    inserted {inserted}/{len(rows)} rows into `{table_name}`", end='\r', flush=True)
        print()
    except Error as e:
        print(f"\n❌ Error inserting into `{table_name}`.")
        print_mysql_error(e)
        conn.rollback()
        raise
    return inserted


def process_csv_files(folder_path, csv_files, db_config, batch_size=1000):
    # quick validation
    if db_config['host'] in ('your_host', '', None):
        raise SystemExit("ERROR: Set DB_CONFIG['host'] to 'localhost' or your DB host/IP before running.")


    # Ensure DB exists (create if missing)
    ensure_database_exists(db_config)


    # Connect using DB
    conn = try_connect(db_config, use_database=True)
    if conn is None:
        print("-> Trying fallback auth_plugin 'mysql_native_password' for full DB connection...")
        conn = try_connect(db_config, use_database=True, auth_plugin='mysql_native_password')
        if conn is None:
            raise SystemExit("Fatal: Could not connect to DB even after fallback attempts. See errors above.")
    cursor = conn.cursor()


    for csv_file, table_name in csv_files:
        file_path = os.path.join(folder_path, csv_file)
        print(f"\n---- Processing {csv_file} -> `{table_name}` ----")
        if not os.path.isfile(file_path):
            print(f"  ❌ File not found: {file_path}. Skipping.")
            continue
        try:
            df = pd.read_csv(file_path, low_memory=False)
        except UnicodeDecodeError:
            print("  - UnicodeDecodeError: retrying with encoding='latin1'")
            df = pd.read_csv(file_path, encoding='latin1', low_memory=False)
        except Exception as e:
            print(f"  ❌ Failed to read CSV: {e}")
            continue
        print(f"  - Rows: {len(df)}, Columns: {len(df.columns)}")
        df.columns = [sanitize_colname(c) for c in df.columns]
        try:
            create_table_from_df(cursor, table_name, df)
            print(f"  - Table `{table_name}` ready.")
        except Error as e:
            print(f"  ❌ Error creating table `{table_name}`:")
            print_mysql_error(e)
            continue
        try:
            inserted = insert_dataframe(cursor, conn, table_name, df, batch_size=batch_size)
            print(f"  - Inserted {inserted} rows into `{table_name}`.")
        except Exception as e:
            print(f"  ❌ Failed to insert for `{table_name}`: {e}")
            # continue to next file


    cursor.close()
    conn.close()
    print("\n✅ Processing finished.")


if __name__ == '__main__':
    process_csv_files(CSV_FOLDER, CSV_FILES, DB_CONFIG, batch_size=BATCH_SIZE)